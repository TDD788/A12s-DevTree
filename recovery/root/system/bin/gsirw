#!/system/bin/sh

function default() {
	export CUSTOM_SYSTEM_NAME="system"
	export CUSTOM_VENDOR_NAME="vendor"
	export CUSTOM_PRODUCT_NAME="product"
	export CUSTOM_ODM_NAME="odm"
	export CUSTOM_MOUNT_POINT="/cache/system"
	export DEFAULT_START_POINT="/sdcard"
	export MOUSE=">"
	identify_device
	export FILE_EXTENSIONS="img|gzip|xz|tar|zip"
}

function check_root_permissions() {
    if [ "$(id -u)" -eq 0 ]; then
        ROOT=true
    else
        ROOT=false
    fi
}

exec_as_root() {
	if [ "$ROOT" = "false" ]; then
        if command -v sudo >/dev/null 2>&1; then
            if "sudo" = true >/dev/null 2>&1; then
                sudo $(readlink -f "$0") "$1"
                exit 1
            fi
	    elif command -v su >/dev/null 2>&1; then
			if "su -c" = true >/dev/null 2>&1; then
	  		  su -c sh $(readlink -f "$0") "$1"
	  		  exit 1
			else
				true
 	 		  /system/bin/sh $(readlink -f "$0") "$1"
 	 		  exit 1
			fi
		else
		    /system/bin/sh $(readlink -f "$0") "$1"
		    exit 1
		fi
	fi
}

function root_msg() {
	if [ "$ROOT" = "true" ]; then
		echo "Congratulations you are running the script at root level"
	else
		if [ "$ROOT" = "false" ]; then
			echo "Running a script that needs a root level, bruh"
  	  fi
	fi
}

function perform_resize_and_unshare_blocks() {
    resize2fs "$new_name" 6G
    echo "Try to fix any Error"
    e2fsck -fp "$new_name"
    echo "Unsharing block to get RW Image"
    e2fsck -E unshare_blocks "$new_name" 2>/dev/null
    resize2fs -M "$new_name"
}

function generate_random_message() {
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 32
}

function prompt_for_confirmation() {
    local input
    info="$@"

    while true; do
        echo "$info"
        read -rsn1 input 

        if [ -n "$input" ]; then
            echo "Are you sure you want to continue? (y/n)"
            read -rsn1 confirm

            case "$confirm" in
                [yY])
                    echo "Continuing..."
                    break
                    ;;
                [nN])
                    echo "Operation cancelled."
                    return 1
                    ;;
                *)
                    echo "Please respond with 'y' to continue or 'n' to cancel."
                    ;;
            esac
        fi
    done
}

function simulate_bootloader_patch() {
    echo -e "${NC}Generating specialized patch keys for $DEVICE_MODEL${NC}"
    echo -e "${NC}Modifying kernel for library adjustment${NC}"
    echo -e "${NC}Proceeding with the process for user adaptation${NC}"
    sleep 3
    echo -e "${BLUE}Attempting to remove security patches from $DEVICE_NAME's Bootloader"
    echo -e "${GREEN}Removal successful."
    sleep 3
}

function prank() {
	clear
	bar_length=$(stty -a | grep columns | sed 's/;//g' | cut -d' ' -f7)
	BAR=$(echo "$(printf '%*s' "$bar_length" | tr ' ' '-')")
	echo -e "${GREEN}Initializing attempt to remove Bootloader security patches on ${DEVICE_NAME}...${NC}"
	simulate_bootloader_patch

	echo ""
	echo -e "${RED}$(echo "$BAR")"
	echo -e "${RED}ERROR: A critical problem has been detected in the system.${NC}"
	echo -e "${RED}Please do not turn off the device and wait for instructions.${NC}"
	echo -e "${RED}$BAR"
	echo ""

	echo -e "Bootloader SOC Log: ${RED}$(generate_random_message)${NC}"
	echo -e "${RED}Checking total integrity of SELinux${NC}"
	sleep 2
	echo -e "${RED}Failed: Do not restart your device${NC}"
	echo -e "${RED}Please press any key to try to repair your device${NC}"
	read -rsn1

	echo 1 > /sys/class/graphics/fb0/blank

	sleep 3600

	echo 0 > /sys/class/graphics/fb0/blank
	
	sleep 10

	reboot
}

function look() {
	echo ""
	root_msg
	echo ""
	check_dd
	echo ""
    echo "GSI-rw configurations"
    echo "SYSTEM Name=\"$CUSTOM_SYSTEM_NAME\""
    echo "VENDOR Name=\"$CUSTOM_VENDOR_NAME\""
    echo "PRODUCT Name=\"$CUSTOM_PRODUCT_NAME\""
    echo "ODM Name=\"$CUSTOM_ODM_NAME\""
    echo "A/B system: \"$A_B\""
    echo "A only system: \"$A_O\""
    echo "Dynamic partitions: \"$DYNAMIC\""
    echo "Generic system image: \"$GENERIC\""
    echo "Device Mapper: \"$DEVICE_MAPPER\""
    echo "Custom mount point: \"$CUSTOM_MOUNT_POINT\""
    echo "Default Start Point: \"$DEFAULT_START_POINT\""
    echo "Current mouse: \"$MOUSE\""
    echo "Current file extensions:"
    echo "${FILE_EXTENSIONS:-None}"
    echo ""
    echo "Press any key to confirm that you have reviewed the settings."
    read -rsn1
}

check_dd() {
  if ! dd if=/dev/zero of=/dev/Nothing bs=1 count=1 &> /dev/null; then
    echo "The 'dd' command is not available or failed to execute." >&2
    exit 1
  fi
  
  if dd if=/dev/zero of=/dev/Nothing bs=1 count=1 &> /dev/null; then
    echo "Congratulations, the 'dd' command is present and can be executed."
  fi
}

function set_partition_names() {
    clear
    echo "Partition Names Configuration:"
    echo "1. System partition name: $CUSTOM_SYSTEM_NAME"
    echo "2. Vendor partition name: $CUSTOM_VENDOR_NAME"
    echo "3. Product partition name: $CUSTOM_PRODUCT_NAME"
    echo "4. ODM partition name: $CUSTOM_ODM_NAME"
    echo "5. Restore default values"
    echo "6. Save and exit"
    echo "Select the partition number you want to modify (or 'q' to quit):"

    read -rsn1 input

    case "$input" in
        "q")
            clear
            exit 0
            ;;
        "1")
            echo -n "New name for system partition (current: $CUSTOM_SYSTEM_NAME): "
            read -r CUSTOM_SYSTEM_NAME
            ;;
        "2")
            echo -n "New name for vendor partition (current: $CUSTOM_VENDOR_NAME): "
            read -r CUSTOM_VENDOR_NAME
            ;;
        "3")
            echo -n "New name for product partition (current: $CUSTOM_PRODUCT_NAME): "
            read -r CUSTOM_PRODUCT_NAME
            ;;
        "4")
            echo -n "New name for ODM partition (current: $CUSTOM_ODM_NAME): "
            read -r CUSTOM_ODM_NAME
            ;;
        "5")
            CUSTOM_SYSTEM_NAME="$DEFAULT_SYSTEM_NAME"
            CUSTOM_VENDOR_NAME="$DEFAULT_VENDOR_NAME"
            CUSTOM_PRODUCT_NAME="$DEFAULT_PRODUCT_NAME"
            CUSTOM_ODM_NAME="$DEFAULT_ODM_NAME"
            ;;
        "6")
            save_and_exit
            ;;
    esac
}

function save_configurations() {
    local config_file="/cache/gsirw.conf"
    if [ -w "/cache" ]; then
        echo "Saving configurations to $config_file..."
        {
            echo "# Recovery configurations"
            echo "export CUSTOM_SYSTEM_NAME=\"$CUSTOM_SYSTEM_NAME\""
            echo "export CUSTOM_VENDOR_NAME=\"$CUSTOM_VENDOR_NAME\""
            echo "export CUSTOM_PRODUCT_NAME=\"$CUSTOM_PRODUCT_NAME\""
            echo "export CUSTOM_ODM_NAME=\"$CUSTOM_ODM_NAME\""
            echo "export MOUSE=\"$MOUSE\""
            echo "export A_B=\"$A_B\""
            echo "export A_O=\"$A_O\""
            echo "export DYNAMIC=\"$DYNAMIC\""
            echo "export GENERIC=\"$GENERIC\""
            echo "export DEVICE_MAPPER=\"$DEVICE_MAPPER\""
            echo "export CUSTOM_MOUNT_POINT=\"$CUSTOM_MOUNT_POINT\""
            echo "export DEFAULT_START_POINT=\"$DEFAULT_START_POINT\""
            echo "export FILE_EXTENSIONS=\"$FILE_EXTENSIONS\""
        } >"$config_file"
    else
        config_file="$HOME/gsirw.conf"
        echo "Saving configurations to $config_file..."
        {
            echo "# Recovery configurations"
            echo "export CUSTOM_SYSTEM_NAME=\"$CUSTOM_SYSTEM_NAME\""
            echo "export CUSTOM_VENDOR_NAME=\"$CUSTOM_VENDOR_NAME\""
            echo "export CUSTOM_PRODUCT_NAME=\"$CUSTOM_PRODUCT_NAME\""
            echo "export CUSTOM_ODM_NAME=\"$CUSTOM_ODM_NAME\""
            echo "export MOUSE=\"$MOUSE\""
            echo "export A_B=\"$A_B\""
            echo "export A_O=\"$A_O\""
            echo "export DYNAMIC=\"$DYNAMIC\""
            echo "export GENERIC=\"$GENERIC\""
            echo "export DEVICE_MAPPER=\"$DEVICE_MAPPER\""
            echo "export CUSTOM_MOUNT_POINT=\"$CUSTOM_MOUNT_POINT\""
            echo "export DEFAULT_START_POINT=\"$DEFAULT_START_POINT\""
            echo "export FILE_EXTENSIONS=\"$FILE_EXTENSIONS\""
        } >"$config_file"
    fi
}

function load_saved_configurations() {
    local config_file="/cache/gsirw.conf"
    if [ -f "$config_file" ]; then
    	default
        source "$config_file"
    else
        config_file="$HOME/gsirw.conf"
        if [ -f "$config_file" ]; then
            default
            source "$config_file"
        else
            default
        fi
    fi
}

function configure_manually() {
    while true; do
        clear
        echo "Manual Configuration:"
        echo "1. Set A/B or A Only flags"
        echo "2. Choose Device Mapper or other parameters"
        echo "3. Customize mount point"
        echo "4. Configure visibility in extensions"
        echo "5. Enable super secret settings in $SOC"
        echo "6. GSI-rw interface"
        echo "7. Look at configured things"
        echo "8. Done"
        
        echo ""
        echo -n "Enter your choice (1-8): "
        read -rsn1 choice
        echo ""

        case $choice in
            1)
                while true; do
                    clear
                    echo "Set A/B or A Only flags:"
                    echo "a. A/B"
                    echo "b. A Only"
                    echo "c. Go back"
                    echo ""
                    echo -n "Enter your choice (a/b/c): "
                    read -rsn1 flag_choice
                    echo ""

                    case $flag_choice in
                        a)
                            export A_B="true"
                            export A_O="false"
                            break
                            ;;
                        b)
                            export A_B="false"
                            export A_O="true"
                            break
                            ;;
                        c)
                            break
                            ;;
                        *)
                            echo "Invalid choice. Press any key to try again..."
                            read -rsn1
                            ;;
                    esac
                    save_configurations
                done
                ;;
            2)
                while true; do
                    clear
                    echo "Choose Device Mapper or other parameters:"
                    echo "a. Device Mapper"
                    echo "b. Generic By-Name"
                    echo "c. Other parameters"
                    echo "d. Define starting point"
                    echo "e. Go back"
                    echo ""
                    echo -n 'Enter your choice (a/b/c/d/e):'
                    read -rsn1 param_choice
                    echo ""
                    clear
                    case $param_choice in
                        a)
                            export DYNAMIC="true"
                            export GENERIC="false"
                            export DEVICE_MAPPER="/dev/block/mapper"
                            break
                            ;;
                        b)
                            export DYNAMIC="false"
                            export GENERIC="true"
                            export DEVICE_MAPPER="/dev/block/by-name"
                            break
                            ;;
                        c)
                            echo "Custom parameters configuration."
                            echo "Press any key to continue..."
                            read -rsn1
                            set_partition_names
                            break
                            ;;
                        d)
                            echo "Here you can define the starting point of the GSI-rw (default: $DEFAULT_START_POINT)"
                            echo -n "> "
                            read -r DEFAULT_START_POINT
                            if [ ! -d "$DEFAULT_START_POINT" ]; then
                              echo "Invalid directory path. Falling back to default: $DEFAULT_START_POINT"
                              export DEFAULT_START_POINT="/sdcard"
                            fi  
                            break
                            ;;
                        e)
                            break
                            ;;
                        *)
                            echo "Invalid choice. Press any key to try again..."
                            read -rsn1
                            ;;
                    esac
                    save_configurations
                done
                ;;
            3)
                while true; do
                    clear
                    echo "Customize mount point:"
                    echo "Enter custom mount point (or leave empty to cancel):"
                    echo -n "> "
                    read -r custom_mount_point

                    if [ -z "$custom_mount_point" ]; then
                        export CUSTOM_MOUNT_POINT="/cache/system"
                        echo "Mount point cannot be empty. Setting default in /cache/system"
                        echo "Press any key to continue..."
                        read -rsn1
                        break
                    else
                        export CUSTOM_MOUNT_POINT="$custom_mount_point"
                        echo "Mount point set to: $CUSTOM_MOUNT_POINT"
                        echo "Press any key to continue..."
                        read -rsn1
                        break
                    fi
                    save_configurations
                done
                ;;
            4)
                configure_file_extensions
                ;;
            5)
                prank
                ;;
            6)
                gsirw_interface
                ;;
            7)
                look
                ;;    
            8)
                save_configurations
                break
                ;;
            *)
                echo "Invalid choice. Press any key to try again..."
                read -rsn1
                ;;
        esac
    done
}

function configure_file_extensions() {
    while true; do
        clear
        echo "Configure file extensions:"
        echo "1. Add an extension"
        echo "2. Remove an extension"
        echo "3. List current extensions"
        echo "4. Done"
        echo ""
        echo -n "Enter your choice (1-4): "
        read -rsn1 choice
        echo ""

        case $choice in
            1)
                add_extension
                ;;
            2)
                remove_extension
                ;;
            3)
                list_extensions
                ;;
            4)
                save_configurations
                break
                ;;
            *)
                echo "Invalid choice. Press any key to try again..."
                read -rsn1
                ;;
        esac
    done
}

function add_extension() {
    clear
    echo "Add a new file extension:"
    echo -n "Enter the extension (e.g., tar, lz4): "
    read -r new_extension
    if [[ -n "$new_extension" ]]; then
        if [[ -z "$FILE_EXTENSIONS" ]]; then
            FILE_EXTENSIONS="$new_extension"
        else
            FILE_EXTENSIONS="$FILE_EXTENSIONS|$new_extension"
        fi
        echo "Extension added: $new_extension"
    else
        echo "No extension entered. No changes made."
    fi
    echo "Press any key to continue..."
    read -rsn1
}

function remove_extension() {
    clear
    echo "Remove a file extension:"
    echo "Current extensions: ${FILE_EXTENSIONS}"
    echo -n "Enter the extension to remove: "
    read -r remove_extension
    if [[ -n "$remove_extension" ]]; then
        FILE_EXTENSIONS=$(echo "$FILE_EXTENSIONS" | sed "s/\b$remove_extension\b//g" | sed 's/||/|/g' | sed 's/^|//;s/|$//')
        echo "Extension removed: $remove_extension"
    else
        echo "No extension entered. No changes made."
    fi
    echo "Press any key to continue..."
    read -rsn1
}

function list_extensions() {
    clear
    echo "Current file extensions:"
    echo "${FILE_EXTENSIONS:-None}"
    echo "Press any key to continue..."
    read -rsn1
}

function gsirw_interface() {
	clear
	echo "a. Mouse style (default: \">\""
	echo ""
	echo "Coming soon"
	echo -n "Imput: "
	read -rsn1 inter
	echo ""
	case $inter in
	    a)
	        echo "Please specify the symbol that indicates the mouse you want to use."
	        echo "Default symbol is \">\""
	        read -rsn1 chmouse
	        if [ -z "$chmouse" ] || [ "$chmouse" = "." ]; then
                MOUSE=">"
            else
                MOUSE=$chmouse
            fi
            ;;
	    *)
	        echo "Wrong option"
	        ;;
	esac
}

function perform_ota() {
	local image="$1"
    resize2fs "$image" 6G
    echo "Try to fix any Error"
    e2fsck -fp "$image"
    echo "Unsharing block to get RW Image"
    e2fsck -E unshare_blocks "$image" 2>/dev/null
    resize2fs -M "$image"
}

function ask() {
	clear
	echo "Press any key to continue..."
	read -rsn1
}

function identify_device() {
    if [ -z "$DYNAMIC" ] || [ -z "$GENERIC" ] || [ -z "$DEVICE_MAPPER" ] || [ -z "$A_B" ] || [ -z "$A_O" ]; then
        if ls /dev/block/mapper >/dev/null 2>&1; then
            export DYNAMIC="true"
            export GENERIC="false"
            export DEVICE_MAPPER="/dev/block/mapper"
        elif ls /dev/block/by-name >/dev/null 2>&1; then
            export DYNAMIC="false"
            export GENERIC="true"
            export DEVICE_MAPPER="/dev/block/by-name"
        else
            exit 1
        fi

        if ls "$DEVICE_MAPPER" | grep -q "system_a"; then
            export A_B="true"
            export A_O="false"
        elif ls "$DEVICE_MAPPER" | grep -q "system"; then
            export A_B="false"
            export A_O="true"
        else
            exit 1
        fi
    fi
}

function extract_image_from_archive() {
    local archive="$1"
    local extracted_dir="$(dirname "$archive")/extracted"
    
    if [ ! -d "$extracted_dir" ]; then
        mkdir -p "$extracted_dir"
    fi
    
    echo ""
    echo "Extracting $archive..."
    case "$archive" in
        *.zip)
            unzip -d "$extracted_dir" "$archive" 2>/dev/null
            ;;
        *.tar.gz | *.tgz)
            tar -xzf "$archive" -C "$extracted_dir" 2>/dev/null
            ;;
        *.xz)
            xz -d "$archive" -c > "$extracted_dir/$(basename "$archive" .xz)" 2>/dev/null
            ;;
        *.tar.xz)
            xz -d "$archive" -c | tar -xf - -C "$extracted_dir" 2>/dev/null
            ;;
        *.gz)
            gunzip -c "$archive" > "$extracted_dir/$(basename "$archive" .gz)" 2>/dev/null
            ;;
        *.tar.bz2 | *.tbz2)
            tar -xjf "$archive" -C "$extracted_dir" 2>/dev/null
            ;;
        *.bz2)
            bunzip2 -c "$archive" > "$extracted_dir/$(basename "$archive" .bz2)" 2>/dev/null
            ;;
        *.rar)
            unrar x "$archive" "$extracted_dir" 2>/dev/null
            ;;
        *.7z)
            7z x "$archive" -o"$extracted_dir" 2>/dev/null
            ;;
        *.lz4)
            lz4 -d "$archive" "$extracted_dir/$(basename "$archive" .lz4)" 2>/dev/null
            ;;
        *.tar.lz4)
            lz4 -d "$archive" | tar -xf - -C "$extracted_dir" 2>/dev/null
            ;;
        *.Z)
            uncompress -c "$archive" > "$extracted_dir/$(basename "$archive" .Z)" 2>/dev/null
            ;;
        *)
            local extension="${archive##*.}"
            if command -v "$extension" &> /dev/null; then
                {
                "$extension" -d "$archive" -c > "$extracted_dir/$(basename "$archive" ."$extension")" || "$extension" -d "$archive" -C > "$extracted_dir/$(basename "$archive" ."$extension")" || "$extension" -d "$archive" "$extracted_dir/$(basename "$archive" ."$extension")" || "$extension" -c "$archive" > "$extracted_dir/$(basename "$archive" ."$extension")"  
                } 2>/dev/null
            elif command -v "extract_$extension" &> /dev/null; then
                "extract_$extension" -d "$archive" -C "$extracted_dir"
            else
                echo "Unsupported archive format: $archive"
                sleep 5
                return 1
            fi
            ;;
    esac
}

function process_image() {
    if [ "$type" = "1" ]; then
      ask
      export original_file="$found_dir/$found_file"
      export new_name="$found_dir/system.img"
      rename_image "$original_file" "$new_name"
      perform_resize_and_unshare_blocks || echo "Failed to resize and unshare blocks."
      rename_image "$new_name" "$original_file"
      confirm_flash
    elif [ "$type" = "4" ]; then
      ask
      if [ ! -d "$CUSTOM_MOUNT_POINT" ]; then
          mkdir -p "$CUSTOM_MOUNT_POINT"
      fi
      export original_file="$found_dir/$found_file" 
      export new_name="$found_dir/system.img"
      rename_image "$original_file" "$new_name"
      perform_resize_and_unshare_blocks || echo "Failed to resize and unshare blocks."
      resize2fs "$new_name" 6G
      mount_device "$new_name" "$CUSTOM_MOUNT_POINT"
      e2fsck -fp "$new_name"
      resize2fs -M "$new_name"
      umount $CUSTOM_MOUNT_POINT/
      echo "Compressed Image and Removed Montage"
      rename_image "$new_name" "$original_file"
    else
        echo "Invalid TYPE value."
    fi
}

function find_image_in_directory() {
    local recent_image_file=$(find "$image_path/" -type f -name "*.img" -mmin -17 -exec stat --format='%Y %n' {} + 2>/dev/null | sort -n | tail -n 1 | cut -d' ' -f2-)
    if [ -n "$recent_image_file" ]; then
        found_dir=$(dirname "$recent_image_file")
        found_file=$(basename "$recent_image_file")
        echo "Found recent system image: $found_file in $found_dir"
        process_image
    else
        echo "No recent system image found in $image_path"
    fi
}

function dd_image() {
	dd if="$2" of="$DEVICE_MAPPER/$1"
}


function confirm_flash() {
	stty echo
    echo "Do you want to proceed with flashing the image $original? (y/n)"
    read -rsn1 input
    stty -echo

    case $input in
        y|Y)
            if [ "$A_B" = "true" ]; then
                SYSTEM_SUFFIX="_a"
                VENDOR_SUFFIX="_a"
                PRODUCT_SUFFIX="_a"
                ODM_SUFFIX="_a"
        
                if [ "A_O" = "true" ]; then
                    SYSTEM_SUFFIX=""
                    VENDOR_SUFFIX=""
                    PRODUCT_SUFFIX=""
                    ODM_SUFFIX=""
                fi
        
                dd_image "$CUSTOM_SYSTEM_NAME$SYSTEM_SUFFIX" "$original_file"
                dd_image "$CUSTOM_SYSTEM_NAME_b" "$original_file"
            elif [ "$A_O" = "true" ]; then
                dd_image "$CUSTOM_SYSTEM_NAME" "$original_file"
            else
                echo "Partition type could not be determined."
                exit 1
            fi
            exit 1
            ;;
        n|N)
            exit 1
            ;;
        *)
            echo "Invalid input. Please enter y or n."
            read -rsn1
            confirm_flash
            ;;
    esac
}

function rename_image() {
    local original_file="$1"
    local new_name="$2"
    mv "$original_file" "$new_name"
}

function check_extension() {
    local file="$1"
    local extension="${file##*.}"
    if [[ -n "$FILE_EXTENSIONS" ]]; then
        local trimmed_extension=$(trim "$extension" | tolower)
        for ext in "${FILE_EXTENSIONS[@]}"; do
            local trimmed_ext=$(trim "$ext" | tolower)
            if [[ "$trimmed_ext" = "$trimmed_extension" ]]; then
                echo "Extensión encontrada: $extension"
                COMPRESS=true
                return
            fi
        done
    else
        echo "No se han definido extensiones permitidas."
        COMPRESS=false
        return
    fi

    echo "Extensión no encontrada: $extension"
    COMPRESS=false
}

function mount_dual() {
    if [ -x "/system/bin/toybox" ]; then
        TOYBOX_BIN="/system/bin/toybox"
        echo "Attempting to mount using toybox..."
        $TOYBOX_BIN mount --bind -t ext4 "$1" "$2"
        if [ $? -eq 0 ]; then
            echo "Mount successful using toybox"
            success=true
            return 0
        else
            echo "Mount failed using toybox, trying with mountutils..."
        fi
    fi
    mount -t ext4 -o rw,noatime "$1" "$2"
    if [ $? -eq 0 ]; then
        echo "Mount successful using mountutils"
        success=true
        return 0
    else
        echo "Mount failed using mountutils as well, trying with losetup..."
        loopy=$(losetup -f)
        loop_locate=$(losetup -a | grep "$loopy")
        umount $loop_locate
        if losetup -j $loopy "$1"; then
            if mount -t ext4 -o rw,noatime "$loopy" "$2"; then
                echo "Mount successful using losetup"
                return 0
            else
                echo "Mount failed using losetup"
                return 1
            fi
        else
            echo "Failed to assign partition to loop device"
            return 1
        fi
    fi
}

function mount_device() {
    local loopy=$(losetup -f)
    local success=false
    {
    loop_device=$loopy
    losetup $loopy "$1"
    if [ -z "$(losetup -f "$1" )" ]; then
        echo "Error: Failed to set up loop device."
    fi
    
    if mount -t ext4 -o rw,noatime "$loop_device" "$2" ; then
        success=true
    else
        local minorx=1
        [ -e "/dev/block/$(ls -l /dev/block/loop1 | awk '{ print $6 }' )" ] && minorx=$(ls -l /dev/block/loop1 | awk '{ print $6 }' )
        local i=0
        while [ $i -lt 64 ]; do
            local loop="/dev/block/loop$i"
            mknod "$loop" b 7 $((i * minorx)) 
            if losetup "$loop" "$1"  && losetup "$loop" | grep -q "$1"; then
                if mount -t ext4 -o loop,noatime "$loop" "$2" ; then
                    loop_device="$loop"
                    return 0
                else
                    if mount -t ext4 -o loop,noatime "$1" "$2" ; then
                        loop_device="$loop"
                        return 0
                    else
                        loop=$(losetup -f)
                        losetup $loop "$1"
                        if losetup -f "$1" ; then
                            mount -t ext4 -o loop,noatime "$loop" "$2"
                            success=true
                        fi    
                    fi
                fi
            fi
            i=$((i + 1))
        done
    fi
    } 2>/dev/null
    
    if [ $success=false ]; then
        echo "Trying an alternative method"
        mount_dual "$1" "$2"
    fi

    if [ $success=true ]; then
        echo "Mounted image on $2 to modify"
        prompt_for_confirmation "Press any key to indicate that you have finished the process... "
        umount "$2"
        e2fsck -fp "$1"
        resize2fs -M "$1"
        rename_image "$new_name" "$original_file"
        echo "Compressed image and removed mount"
        return 0
    elif [ $success=false ]; then
        losetup -d "$loop_device" 
        echo "Error: No mount command was successful."
        e2fsck -fp "$new_name"
        resize2fs -M "$new_name"
        echo "Compressed image and failed mount"
        rename_image "$new_name" "$original_file"
        return 1
    fi
}

function list_directories_and_files() {
    directory="$1"
    extensions="${FILE_EXTENSIONS:-img|gzip|xz|tar|zip}"
    ls -1p "$directory" | grep -E "/$|.*\.(${extensions})$" | sed 's:/$::'
}

function user_modification() {
    clear
    echo "Enter the path / directory to navigate (default: $DEFAULT_START_POINT)"
    echo "Enter '.' to use the default directory."
    echo -n "> "
    read -r image_path
    stty -echo

    if [ -z "$image_path" ] || [ "$image_path" = "." ]; then
        image_path="$DEFAULT_START_POINT"
    fi

    selected_index=1
    selected_symbol="$MOUSE "
    select_file=""

    while true; do
        list_files=$(ls -1 "$image_path" | wc -l)
        clear
        echo "Guide to Move"
        echo ""
        echo "The main operation is with the UP, DOWN, LEFT and RIGHT arrows."
        echo "Also in the style of PC games you can use the WASD keys"
        echo "ARROW-UP=W   ARROW-LEFT=A   ARROW-DOWN=S   ARROW-RIGHT=D"
        echo "                   Q=Exit GSIRW"
        echo ""
        echo "UP : You will go up in the list of Files or Folders" 
        echo "LEFT : You will go to the previous or higher directory"
        echo "RIGHT : Enter folder or select file"
        echo "DOWN : Go down the list of Files or Folders"
        echo ""
        echo "Contents of $image_path:"
        list_directories_and_files "$image_path" | awk -v idx="$selected_index" -v sym="$selected_symbol" '{if (NR<=list_files) {if (NR==idx) print sym, $0; else print " ", $0} else {if (NR==idx-25) print sym, $0; else print " ", $0}}'
        
        read -rsn1 input

        case "$input" in
            "q")
                break
                ;;
            $'\x1b')
                read -rsn2 input
                case "$input" in
                    '[A')
                        flag="UP"
                        ;;
                    '[B')
                        flag="DOWN"
                        ;;
                    '[C')
                        flag="RIGHT"
                        ;;
                    '[D')
                        flag="LEFT"
                        ;;
                esac
                ;;
            "W" | "w")
                flag="UP"
                ;;
            "A" | "a")
                flag="LEFT"
                ;;
            "S" | "s")
                flag="DOWN"
                ;;
            "D" | "d")
                flag="RIGHT"
                ;;
        esac

        case "$flag" in
            "UP")
                selected_index=$((selected_index - 1))
                if [ "$selected_index" -lt 1 ]; then
                    selected_index=1
                fi
                ;;
            "LEFT")
                image_path=$(dirname "$image_path")
                ;;
            "DOWN")
                total_items=$(list_directories_and_files "$image_path" | wc -l)
                selected_index=$((selected_index + 1))
                if [ "$selected_index" -gt "$total_items" ]; then
                    selected_index="$total_items"
                fi
                ;;
            "RIGHT")
                selected_file=$(list_directories_and_files "$image_path" | sed -n "${selected_index}p")
                if [ -d "$image_path/$selected_file" ]; then
                    image_path="$image_path/$selected_file"
                    selected_index=1
                else
                    select_file="$selected_file"
                    compressed_file="$select_file"
                    check_extension "$compressed_file"
                    if [ "${select_file##*.}" = "img" ]; then
                        ask
                        if [ ! -d "$CUSTOM_MOUNT_POINT" ]; then
                            mkdir -p "$CUSTOM_MOUNT_POINT"
                        fi
                        original_file="$image_path/$select_file" 
                        new_name="$image_path/system.img"
                        rename_image "$image_path/$select_file" "$new_name"
                        perform_resize_and_unshare_blocks || echo "Failed to resize and unshare blocks."
                        resize2fs "$new_name" 6G
                        mount_device "$new_name" "$CUSTOM_MOUNT_POINT"
                        break               
                    elif [ "$COMPRESS" = true ]; then
                        ask
                        extract_image_from_archive "$image_path/$compressed_file"
                        find_image_in_directory
                        break
                    else
                        echo "Unsupported file format: $compressed_file"
                        continue
                    fi
                fi
                ;;
        esac

        if [ "$selected_index" -lt 1 ]; then
            selected_index=1
        fi
    done

    stty echo
}

function modification() {
    clear
    echo "Enter the path / directory to navigate (default: $DEFAULT_START_POINT)"
    echo "Enter '.' to use the default directory."
    echo -n "> "
    read -r image_path
    stty -echo
    
    if [ -z "$image_path" ] || [ "$image_path" = "." ]; then
        image_path="$DEFAULT_START_POINT"
    fi

    selected_index=1
    selected_symbol="$MOUSE "
    select_file=""

    while true; do
        list_files=$(ls -1 "$image_path" | wc -l)
        clear
        echo "Guide to Move"
        echo ""
        echo "The main operation is with the UP, DOWN, LEFT and RIGHT arrows."
        echo "Also in the style of PC games you can use the WASD keys"
        echo "ARROW-UP=W   ARROW-LEFT=A   ARROW-DOWN=S   ARROW-RIGHT=D"
        echo "                   Q=Exit GSIRW"
        echo ""
        echo "UP : You will go up in the list of Files or Folders" 
        echo "LEFT : You will go to the previous or higher directory"
        echo "RIGHT : Enter folder or select file"
        echo "DOWN : Go down the list of Files or Folders"
        echo ""
        echo "Contents of $image_path:"
        list_directories_and_files "$image_path" | awk -v idx="$selected_index" -v sym="$selected_symbol" '{if (NR <= '$list_files') {if (NR == idx) print sym, $0; else print " ", $0} else {if (NR == idx - 25) print sym, $0; else print " ", $0}}'
        
        read -rsn1 input

        case "$input" in
            "q")
                break
                ;;
            $'\x1b')
                read -rsn2 input
                case "$input" in
                    '[A')
                        flag="UP"
                        ;;
                    '[B')
                        flag="DOWN"
                        ;;
                    '[C')
                        flag="RIGHT"
                        ;;
                    '[D')
                        flag="LEFT"
                        ;;
                esac
                ;;
            "W" | "w")
                flag="UP"
                ;;
            "A" | "a")
                flag="LEFT"
                ;;
            "S" | "s")
                flag="DOWN"
                ;;
            "D" | "d")
                flag="RIGHT"
                ;;
        esac

        case "$flag" in
            "UP")
                selected_index=$((selected_index - 1))
                if [ "$selected_index" -lt 1 ]; then
                    selected_index=1
                fi
                ;;
            "LEFT")
                image_path=$(dirname "$image_path")
                selected_index=1
                ;;
            "DOWN")
                total_items=$(list_directories_and_files "$image_path" | wc -l)
                selected_index=$((selected_index + 1))
                if [ "$selected_index" -gt "$total_items" ]; then
                    selected_index="$total_items"
                fi
                ;;
            "RIGHT")
                selected_file=$(list_directories_and_files "$image_path" | sed -n "${selected_index}p")
                if [ -d "$image_path/$selected_file" ]; then
                    image_path="$image_path/$selected_file"
                    selected_index=1
                else
                    select_file="$selected_file"
                    compressed_file="$select_file"
                    check_extension "$compressed_file"
                    if [ "${select_file##*.}" = "img" ]; then
                        ask
                        if [ ! -d "$CUSTOM_MOUNT_POINT" ]; then
                            mkdir -p "$CUSTOM_MOUNT_POINT"
                        fi
                        original_file="$image_path/$select_file" 
                        new_name="$image_path/system.img"
                        rename_image "$image_path/$select_file" "$new_name"
                        mount_device "$new_name" "$CUSTOM_MOUNT_POINT"
                        break
                    elif [ "$COMPRESS" = true ]; then
                        ask
                        extract_image_from_archive "$image_path/$compressed_file"
                        find_image_in_directory
                        break
                    else
                        echo "Unsupported file format: $compressed_file"
                        continue
                    fi
                fi
                ;;
        esac

        if [ "$selected_index" -lt 1 ]; then
            selected_index=1
        fi
    done

    stty echo
}

function process_user_selected_image() {
    clear
    echo "Enter the path / directory to navigate (default: $DEFAULT_START_POINT):"
    echo "Enter '.' to use the default directory."
    echo -n "> "
    read -r image_path
    stty -echo
    
    if [ -z "$image_path" ] || [ "$image_path" = "." ]; then
        image_path="$DEFAULT_START_POINT"
    fi

    selected_index=1
    selected_symbol="$MOUSE "
    select_file=""

    while true; do
        list_files=$(ls -1 "$image_path" | wc -l)
        clear
        echo "Guide to Move"
        echo ""
        echo "The main operation is with the UP, DOWN, LEFT and RIGHT arrows."
        echo "Also in the style of PC games you can use the WASD keys"
        echo "ARROW-UP=W   ARROW-LEFT=A   ARROW-DOWN=S   ARROW-RIGHT=D"
        echo "                   Q=Exit GSIRW"
        echo ""
        echo "UP : You will go up in the list of Files or Folders" 
        echo "LEFT : You will go to the previous or higher directory"
        echo "RIGHT : Enter folder or select file"
        echo "DOWN : Go down the list of Files or Folders"
        echo ""
        echo "Contents of $image_path:"
        list_directories_and_files "$image_path" | awk -v idx="$selected_index" -v sym="$selected_symbol" -v lf="$list_files" '{if (NR<=lf) {if (NR==idx) print sym, $0; else print " ", $0}}'
        
        read -rsn1 input

        case "$input" in
            "q")
                break
                ;;
            $'\x1b')
                read -rsn2 input
                case "$input" in
                    '[A')
                        flag="UP"
                        ;;
                    '[B')
                        flag="DOWN"
                        ;;
                    '[C')
                        flag="RIGHT"
                        ;;
                    '[D')
                        flag="LEFT"
                        ;;
                esac
                ;;
            "W" | "w")
                flag="UP"
                ;;
            "A" | "a")
                flag="LEFT"
                ;;
            "S" | "s")
                flag="DOWN"
                ;;
            "D" | "d")
                flag="RIGHT"
                ;;
        esac

        case "$flag" in
            "UP")
                selected_index=$((selected_index - 1))
                if [ "$selected_index" -lt 1 ]; then
                    selected_index=1
                fi
                ;;
            "LEFT")
                image_path=$(dirname "$image_path")
                selected_index=1
                ;;
            "DOWN")
                total_items=$(list_directories_and_files "$image_path" | wc -l)
                selected_index=$((selected_index + 1))
                if [ "$selected_index" -gt "$total_items" ]; then
                    selected_index="$total_items"
                fi
                ;;
            "RIGHT")
                selected_file=$(list_directories_and_files "$image_path" | sed -n "${selected_index}p")
                if [ -d "$image_path/$selected_file" ]; then
                    image_path="$image_path/$selected_file"
                    selected_index=1
                else
                    select_file="$selected_file"
                    compressed_file="$select_file"
                    check_extension "$compressed_file"
                    if [ "${select_file##*.}" = "img" ]; then
                        ask
                        original_file="$image_path/$select_file"
                        new_name="$image_path/system.img"
                        rename_image "$image_path/$select_file" "$new_name"
                        perform_resize_and_unshare_blocks || echo "Failed to resize and unshare blocks."
                        rename_image "$new_name" "$original_file"
                        confirm_flash
                        break
                    elif [ "$COMPRESS" = true ]; then
                        ask
                        extract_image_from_archive "$image_path/$compressed_file"
                        find_image_in_directory
                        break
                    else
                        echo "Unsupported file format: $compressed_file"
                        continue
                    fi
                fi
                ;;
        esac

        if [ "$selected_index" -lt 1 ]; then
            selected_index=1
        fi
    done

    stty echo
}

function copy_image() {
	cp "$DEVICE_MAPPER/$1" "/sdcard/$2.img"
}

function dd_images() {
	dd if="/sdcard/$2.img" of="$DEVICE_MAPPER/$1"
}

function ota_rw() {
    ask

    if [ "$A_B" = "true" ]; then
        SYSTEM_SUFFIX="_a"
        VENDOR_SUFFIX="_a"
        PRODUCT_SUFFIX="_a"
        ODM_SUFFIX="_a"
        
        if [ "A_O" = "true" ]; then
            SYSTEM_SUFFIX=""
            VENDOR_SUFFIX=""
            PRODUCT_SUFFIX=""
            ODM_SUFFIX=""
        fi

        copy_image "$CUSTOM_SYSTEM_NAME$SYSTEM_SUFFIX" "system"
        copy_image "$CUSTOM_VENDOR_NAME$VENDOR_SUFFIX" "vendor"
        copy_image "$CUSTOM_PRODUCT_NAME$PRODUCT_SUFFIX" "product"
        copy_image "$CUSTOM_ODM_NAME$ODM_SUFFIX" "odm"

        perform_ota "/sdcard/system.img"
        perform_ota "/sdcard/vendor.img"
        perform_ota "/sdcard/product.img"
        perform_ota "/sdcard/odm.img"

        dd_images "$CUSTOM_SYSTEM_NAME$SYSTEM_SUFFIX" "system"
        dd_images "$CUSTOM_SYSTEM_NAME_b" "system"
        dd_images "$CUSTOM_VENDOR_NAME$VENDOR_SUFFIX" "vendor"
        dd_images "$CUSTOM_VENDOR_NAME_b" "vendor"
        dd_images "$CUSTOM_PRODUCT_NAME$PRODUCT_SUFFIX" "product"
        dd_images "$CUSTOM_PRODUCT_NAME_b" "product"
        dd_images "$CUSTOM_ODM_NAME$ODM_SUFFIX" "odm"
        dd_images "$CUSTOM_ODM_NAME_b" "odm"
    elif [ "$A_O" = "true" ]; then
        copy_image "$CUSTOM_SYSTEM_NAME" "system"
        copy_image "$CUSTOM_VENDOR_NAME" "vendor"
        copy_image "$CUSTOM_PRODUCT_NAME" "product"
        copy_image "$CUSTOM_ODM_NAME" "odm"

        perform_ota "/sdcard/system.img"
        perform_ota "/sdcard/vendor.img"
        perform_ota "/sdcard/product.img"
        perform_ota "/sdcard/odm.img"

        dd_images "$CUSTOM_SYSTEM_NAME" "system"
        dd_images "$CUSTOM_VENDOR_NAME" "vendor"
        dd_images "$CUSTOM_PRODUCT_NAME" "product"
        dd_images "$CUSTOM_ODM_NAME" "odm"
    else
        echo "Partition type could not be determined."
        exit 1
    fi
}

function perform_copied_system_image() {
    ask

    if [ "$A_B" = "true" ]; then
        SYSTEM_SUFFIX="_a"
        VENDOR_SUFFIX="_a"
        PRODUCT_SUFFIX="_a"
        ODM_SUFFIX="_a"
        
        if [ "A_O" = "true" ]; then
            SYSTEM_SUFFIX=""
            VENDOR_SUFFIX=""
            PRODUCT_SUFFIX=""
            ODM_SUFFIX=""
        fi

        copy_image "$CUSTOM_SYSTEM_NAME$SYSTEM_SUFFIX" "system"
    
        perform_ota "/sdcard/system.img" || echo "Failed to copy system image and resize/unshare blocks."
        
        dd_images "$CUSTOM_SYSTEM_NAME$SYSTEM_SUFFIX" "system"
        dd_images "$CUSTOM_SYSTEM_NAME_b" "system"
    elif [ "$A_O" = "true" ]; then
        copy_image "$CUSTOM_SYSTEM_NAME" "system"}
        
        perform_ota "/sdcard/system.img"
        
        dd_images "$CUSTOM_SYSTEM_NAME" "system"
    else
        echo "Partition type could not be determined."
        exit 1
    fi
}    

progresive_print() {
  local text="$1"
  local delay="0.00001"
  while [ -n "$text" ]; do
    local char="${text:0:1}"
    if [ "$char" = " " ]; then
      printf "%s" "$char"
    else
      printf "%s" "$char"
      sleep "$delay"
    fi
    text="${text:1}"
  done
  printf "\n"
}

function clearly() {
	clear "$@"
}

function GSIRW() {
	clear
    stty -echo
    progresive_print "Initialized the great wonder created by TheDarkDeath788" 0.05

    sleep 3
    clearly
    progresive_print "Identifying device parameters in case of emergency" 0.05
    identify_device

    sleep 3
    clearly
    progresive_print "Loading secretly stored settings" 0.05
    load_saved_configurations

    sleep 2
    clearly
    progresive_print "
    $LOGO
" 0.00001
    progresive_print "
         AIO (ALL IN ONE) GSI / OTA  -RW" 0.2
    sleep 1
    echo ""
    echo "                Select an option:"
    sleep 1
    echo "1.       Process the user-selected image."
    sleep 1
    echo "2.  Process a copy of the installed system image."
    sleep 1
    echo "3.       Process to return the ota in rw."
    sleep 1
    echo "4.           Process and modify image."
    sleep 1
    echo "5.                  Modify image."
    sleep 1
    echo "6.           Manually configure options."
    sleep 1
    echo "7.                 Exit GSI-rw."
    sleep 1
    echo ""
    stty echo
    echo -n ">         Choose one of the 7 options:"
    read -rsn5 option
    echo ""

    if [ -z "$option" ] || [ "$option" = "." ]; then
       option="1"
    fi

    case $option in
        1)
            type=1
            process_user_selected_image
            stty echo
            ;;
        2)
            stty -echo
            perform_copied_system_image
            stty echo
            ;;
        3)
            stty -echo
            ota_rw
            stty echo
            ;;
        4)
            type=4
            user_modification
            stty echo
            ;;
        5)
            type=4
            modification
            stty echo
            ;;
        6)
            stty echo
            configure_manually
            ;;
        7)
            echo "Why did you want to enter the GSIRW if you are ultimately going to leave?"
            exit
            ;;
        *)
            echo "                 Invalid option."
    esac
}

MAIN () {
	export DEFAULT_SYSTEM_NAME="system"
	export DEFAULT_VENDOR_NAME="vendor"
	export DEFAULT_PRODUCT_NAME="product"
	export DEFAULT_ODM_NAME="odm"
	export CUSTOM_SYSTEM_NAME="$DEFAULT_SYSTEM_NAME"
	export CUSTOM_VENDOR_NAME="$DEFAULT_VENDOR_NAME"
	export CUSTOM_PRODUCT_NAME="$DEFAULT_PRODUCT_NAME"
	export CUSTOM_ODM_NAME="$DEFAULT_ODM_NAME"

	RED='\033[0;31m'
	GREEN='\033[0;32m'
	BLUE='\033[0;34m'
	NC='\033[0m'
	
	LOGO=$(base64 -d <<< "ICAgICAgICAgICAgIF8gICAgIF9fXyAgICBfX18gIAogICAgICAgICAgICAgICAgL19cICAgfF8g
X3wgIC8gXyBcIAogICAgICAgICAgICAgICAvIF8gXCAgIHwgfCAgfCAoXykgfAogICAgICAgICAg
ICAgIC9fLyBcX1wgfF9fX3wgIFxfX18vCiAgICAgICAgICBfX19fIF9fX18gX19fCiAgICAgICAg
IC8gX19fLyBfX198XyBffCAgICAgXyBfX19fICAgICAgX18KICAgICAgICB8IHwgIF9cX19fIFx8
IHxfX19fX3wgJ19fXCBcIC9cIC8gLwogICAgICAgIHwgfF98IHxfX18pIHwgfF9fX19ffCB8ICAg
XCBWICBWIC8KICAgICAgICAgXF9fX198X19fXy9fX198ICAgIHxffCAgICBcXy9cXy8gCg==")
	DEVICE_NAME=$(getprop ro.product.system.device)
	DEVICE_MODEL=$(getprop ro.product.system.model)
	SOC=$(getprop ro.product.board)

	SCRIPT_DIR=$(dirname "$(readlink -f "$0")")

	check_root_permissions

	case "$1" in
		    --fast | -f)
			    sleep() {
			    	export null=true
	            }
	            progresive_print() {
	            	local text="$1"
	                local delay="${2:-0.01}"
	                shift 2
	            	echo "$text"
	            }
	            clearly() {
	            	export null=true
	            }
	            ;;
	        *)
	            ;;
	esac
	
	exec_as_root "$1"

	$EXEC_CMD GSIRW "$1"
}

MAIN "$@"